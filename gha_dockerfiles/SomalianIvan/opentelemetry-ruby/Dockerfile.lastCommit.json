[{"sha":"463c14c3581641ce57270c1c7cfb91715cfd2c3e","node_id":"MDY6Q29tbWl0MzIwOTgwMzAzOjQ2M2MxNGMzNTgxNjQxY2U1NzI3MGMxYzdjZmI5MTcxNWNmZDJjM2U=","commit":{"author":{"name":"Andrew Hayworth","email":"ahayworth@github.com","date":"2021-04-15T16:04:46Z"},"committer":{"name":"GitHub","email":"noreply@github.com","date":"2021-04-15T16:04:46Z"},"message":"feat: Add instrumentation for postgresql (pg gem) (#659)\n\n* feat: Add instrumentation for postgresql (pg gem)\r\n\r\nThis commit adds tracing for postgresql, via the `pg` gem.\r\n\r\nThe following methods are traced:\r\n- exec / query / sync_exec / async_exec\r\n- exec_params / sync_exec_params / async_exec_params\r\n- prepare / sync_prepare / async_prepare\r\n- exec_prepared / sync_exec_prepared / async_exec_prepared\r\n\r\nWe instrument all of these methods via meta-programming, since otherwise\r\nit'd be incredibly repetitive. The methods can actually be broken down\r\ninto three groups - \"exec-ish\", \"prepare-ish\", and \"exec prepared-ish\"\r\nmethods. Every method within a group takes the same arguments, and so\r\nwe can trace each method in a group in an identical fashion.\r\n\r\nNote that the 'sync' and 'async' variants require no special handling,\r\nbecause they are not async interfaces _per se_ - rather, they are\r\nnon-blocking. See the `pg` docs for more info: https://www.rubydoc.info/gems/pg/PG%2FConnection:exec\r\n\r\nWe've implemented SQL sanitization the same way that the Mysql2 gem did\r\nit - which seems to be done by copying NewRelic. We should consider\r\nextracting that from the NewRelic agent and making it a common shared\r\nlibrary here.\r\n\r\nPossibly worth discussion is how we've handled the span name. We've\r\nchosen the format `OPERATION_NAME DATABASE_NAME`, taking the first word\r\nin the SQL string as the operation if it matches a known good list we\r\npulled from the Postgres docs. This is similar to how the python and\r\njavascript postgres implementations behave, but is slightly different\r\nthan how the ruby mysql instrumentation does it. When falling back to\r\nsafe value, we also choose to simply use `DATABASE_NAME`, which seems to\r\nbe in line with current semantic conventions.\r\n\r\nWhile tests pass and we think this is safe, it should be noted that we\r\nhaven't actually put this into production testing yet - there could be\r\nhorrible bugs still. :)\r\n\r\nFixes #523\r\n\r\n* test: Attempt to fix CI for pg instrumentation\r\n\r\n* test: Add explicit postgres hostname\r\n\r\n* test: Fix CI\r\n\r\n* feat: Add lru cache for prepared statement names\r\n\r\nThis uses an LRU cache to store the 50 most recently-prepared database\r\nstatements. The goal is to provide something more descriptive than\r\n'EXECUTE a1', which is basically what you get when Rails aggressively\r\nprepares and executes statements.\r\n\r\n50 seems to me like a reasonable trade-off between usefulness and\r\ncapping memory growth. However, it is technically unbounded if you are\r\nnot sanitizing SQL - although we could decide to truncate unconditionally.\r\n\r\n* fix: Bump version numbers after 0.16 release\r\n\r\n* Remove dependency on lru_redux\r\n\r\nWe implement the bare minimum of an LRU cache ourselves, instead.\r\n\r\n* Update to require new opentelemetry-instrumentation-base\r\n\r\n* Move minimum pg version constant to instrumentation class","tree":{"sha":"952987a2b748575e10ce0c257ceff657ece73131","url":"https://api.github.com/repos/SomalianIvan/opentelemetry-ruby/git/trees/952987a2b748575e10ce0c257ceff657ece73131"},"url":"https://api.github.com/repos/SomalianIvan/opentelemetry-ruby/git/commits/463c14c3581641ce57270c1c7cfb91715cfd2c3e","comment_count":0,"verification":{"verified":true,"reason":"valid","signature":"-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgeGQeCRBK7hj4Ov3rIwAAdHIIAC5kVC2scjqpPM39UqKCEiH9\n4c3ZnQzXhL53sUqH7Bi6INm3yvpF2eHYND0omxR6bQEDggWPauaeTLI6eYwxvOTV\nXzqL75xSMnknddA6NTbdukr0qXqDJ/4dVKewBgX44AioWxr5qOCNBWOyCVhksqSw\nY6DIB8wfRFVmy0i2EDACdVB1KWIZTX6oa6s3pzw27gbCJipry/SlHBs5l4SBciK5\nvb+fc2moF583jcT/39TuobPqlVHHOvBCRtJ4nEl3040ThDZ2l2aPlGM1PaDCo91i\nBelng6iUxAQvNi+AEA7yPkybNpozLupUGT8iWF2vbJ2CFFiYW9E1/kT6SiXXkgA=\n=0RAA\n-----END PGP SIGNATURE-----\n","payload":"tree 952987a2b748575e10ce0c257ceff657ece73131\nparent b7149fb72cad6c45956a6be80acfb2d062aab3a6\nauthor Andrew Hayworth <ahayworth@github.com> 1618502686 -0500\ncommitter GitHub <noreply@github.com> 1618502686 -0700\n\nfeat: Add instrumentation for postgresql (pg gem) (#659)\n\n* feat: Add instrumentation for postgresql (pg gem)\r\n\r\nThis commit adds tracing for postgresql, via the `pg` gem.\r\n\r\nThe following methods are traced:\r\n- exec / query / sync_exec / async_exec\r\n- exec_params / sync_exec_params / async_exec_params\r\n- prepare / sync_prepare / async_prepare\r\n- exec_prepared / sync_exec_prepared / async_exec_prepared\r\n\r\nWe instrument all of these methods via meta-programming, since otherwise\r\nit'd be incredibly repetitive. The methods can actually be broken down\r\ninto three groups - \"exec-ish\", \"prepare-ish\", and \"exec prepared-ish\"\r\nmethods. Every method within a group takes the same arguments, and so\r\nwe can trace each method in a group in an identical fashion.\r\n\r\nNote that the 'sync' and 'async' variants require no special handling,\r\nbecause they are not async interfaces _per se_ - rather, they are\r\nnon-blocking. See the `pg` docs for more info: https://www.rubydoc.info/gems/pg/PG%2FConnection:exec\r\n\r\nWe've implemented SQL sanitization the same way that the Mysql2 gem did\r\nit - which seems to be done by copying NewRelic. We should consider\r\nextracting that from the NewRelic agent and making it a common shared\r\nlibrary here.\r\n\r\nPossibly worth discussion is how we've handled the span name. We've\r\nchosen the format `OPERATION_NAME DATABASE_NAME`, taking the first word\r\nin the SQL string as the operation if it matches a known good list we\r\npulled from the Postgres docs. This is similar to how the python and\r\njavascript postgres implementations behave, but is slightly different\r\nthan how the ruby mysql instrumentation does it. When falling back to\r\nsafe value, we also choose to simply use `DATABASE_NAME`, which seems to\r\nbe in line with current semantic conventions.\r\n\r\nWhile tests pass and we think this is safe, it should be noted that we\r\nhaven't actually put this into production testing yet - there could be\r\nhorrible bugs still. :)\r\n\r\nFixes #523\r\n\r\n* test: Attempt to fix CI for pg instrumentation\r\n\r\n* test: Add explicit postgres hostname\r\n\r\n* test: Fix CI\r\n\r\n* feat: Add lru cache for prepared statement names\r\n\r\nThis uses an LRU cache to store the 50 most recently-prepared database\r\nstatements. The goal is to provide something more descriptive than\r\n'EXECUTE a1', which is basically what you get when Rails aggressively\r\nprepares and executes statements.\r\n\r\n50 seems to me like a reasonable trade-off between usefulness and\r\ncapping memory growth. However, it is technically unbounded if you are\r\nnot sanitizing SQL - although we could decide to truncate unconditionally.\r\n\r\n* fix: Bump version numbers after 0.16 release\r\n\r\n* Remove dependency on lru_redux\r\n\r\nWe implement the bare minimum of an LRU cache ourselves, instead.\r\n\r\n* Update to require new opentelemetry-instrumentation-base\r\n\r\n* Move minimum pg version constant to instrumentation class"}},"url":"https://api.github.com/repos/SomalianIvan/opentelemetry-ruby/commits/463c14c3581641ce57270c1c7cfb91715cfd2c3e","html_url":"https://github.com/SomalianIvan/opentelemetry-ruby/commit/463c14c3581641ce57270c1c7cfb91715cfd2c3e","comments_url":"https://api.github.com/repos/SomalianIvan/opentelemetry-ruby/commits/463c14c3581641ce57270c1c7cfb91715cfd2c3e/comments","author":{"login":"ahayworth","id":1781907,"node_id":"MDQ6VXNlcjE3ODE5MDc=","avatar_url":"https://avatars.githubusercontent.com/u/1781907?v=4","gravatar_id":"","url":"https://api.github.com/users/ahayworth","html_url":"https://github.com/ahayworth","followers_url":"https://api.github.com/users/ahayworth/followers","following_url":"https://api.github.com/users/ahayworth/following{/other_user}","gists_url":"https://api.github.com/users/ahayworth/gists{/gist_id}","starred_url":"https://api.github.com/users/ahayworth/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/ahayworth/subscriptions","organizations_url":"https://api.github.com/users/ahayworth/orgs","repos_url":"https://api.github.com/users/ahayworth/repos","events_url":"https://api.github.com/users/ahayworth/events{/privacy}","received_events_url":"https://api.github.com/users/ahayworth/received_events","type":"User","site_admin":false},"committer":{"login":"web-flow","id":19864447,"node_id":"MDQ6VXNlcjE5ODY0NDQ3","avatar_url":"https://avatars.githubusercontent.com/u/19864447?v=4","gravatar_id":"","url":"https://api.github.com/users/web-flow","html_url":"https://github.com/web-flow","followers_url":"https://api.github.com/users/web-flow/followers","following_url":"https://api.github.com/users/web-flow/following{/other_user}","gists_url":"https://api.github.com/users/web-flow/gists{/gist_id}","starred_url":"https://api.github.com/users/web-flow/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/web-flow/subscriptions","organizations_url":"https://api.github.com/users/web-flow/orgs","repos_url":"https://api.github.com/users/web-flow/repos","events_url":"https://api.github.com/users/web-flow/events{/privacy}","received_events_url":"https://api.github.com/users/web-flow/received_events","type":"User","site_admin":false},"parents":[{"sha":"b7149fb72cad6c45956a6be80acfb2d062aab3a6","url":"https://api.github.com/repos/SomalianIvan/opentelemetry-ruby/commits/b7149fb72cad6c45956a6be80acfb2d062aab3a6","html_url":"https://github.com/SomalianIvan/opentelemetry-ruby/commit/b7149fb72cad6c45956a6be80acfb2d062aab3a6"}]}]